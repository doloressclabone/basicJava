package F_OOP2;

public class InheritanceBasic {
	public static void main(String[] args) {
		/*
		상속
		Ex)	직사각형은 사각형이다.
			직사각형은 사각형을 포함하고 있다.
			이상엽은 사람이다.
			이상엽은 사람을 포함하고 있다.
			(낮은 단계가 큰 단계를 포함하고 있다)
			(낮은 단계가 큰 단계이냐)
		1.상속(is a : ~은 ~이다)
		-기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		-적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		-새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을
		키워드 'extends'와 함께 서주기만 하면 된다.
		class Child extends Parent{
			.....
		}
		-상속해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라 한다.
		:조상클래스 - 부모클래스, 상위클래스, 기반클래스
		:자손클래스 - 자식클래스, 하위클래스, 파생클래스
		
		-멤버만 상속 받는다(멤버변수(클래스,인스턴스)와 메소드(클래스메소드,인스턴스메소드).
		-자손클래스의 멤버의 개수는 조상 클래스보다 같거나 많다.
		
		2.포함(has a : ~은 ~을 포함하고 있다)
		-상속이외의 클래스를 재사용하는 방법
		-한 클래스의 멤버변수로 다른 클래스를 선언하는 방법이다.
		
		3.단일상속
		-자바에서는 단일상속만 가능하다(두개 이상은 불가능).
		class TVCR extends TV,VCR{ //불가능 -> 같은 메소드명과 같은 변수명을 가질 수 없기 때문이다.
		}
		-Tv와 VCR에 동일한 멤버가 있을 때 어떤 것을 상속받을지 알 수 없다.
		-VCR의 멤버명을 바꾼다면 그동안 VCR의 멤버를 사용하던 부분들을 모두 수정해주어야 한다.
		-클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있다.
		
		4.Object클래스(모든 클래스의 조상)
		-모든 클래스의 상속 계층도의 가장 위에 위치하는 조상 클래스이다. 
		-extends가 없으면 JVM이 object를 extends해준다.
		-다른 클래스로부터 상속받지 않는 클래스들은 자동적으로 object클래스를 상속받는다.
		
		class Tv{
		}
		=>컴파일 후
		class Tv /*extends Object{
			Tv(){
				super();
			}
		}*/ /*-> 숨겨진 것들*/
		/*
		-toString()나 equals()와 같은 메소드를 따로 정의하지 않고 사용할 수 있는 것은 object클래스에 정의된 것들이기 때문이다.
		
		5.Override
		-조상클래스로부터 상속받은 메소드의 내용을 변경(재정의)하는 것.
		-오버라이드가 되기 위한 조건 => 선언부가 일치 해야 한다.
		:자손클래스에서 오버라이드 하는 메소드는 조상클래스의 메소드의 명과 동일해야 한다.
		:매개변수의 타입과 갯수가 같아야 한다.
		:리턴타입이 같아야 한다.
		:접근제어자를 조상클래스보다 좁은 범위로 설정할 수 없다.
		:예외는 조상 클래스의 메소드보다 많이 선언할 수 없다.
		
		6.super. ('이 인스턴스'의 라는 의미를 가지고 있음)
		-조상클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 있을 때 서로 구분하기 위해 사용한다.
		-조상멤버와 자신의 멤버를 구별하는데 사용한다는 것을 제외하고는 this와 근본적으로 동일하다
		-static 메소드에서 사용할 수 없다.
		
		7.super()
		-this():생성자 내에서 다른 생성자를 부를때
		-super():조상클래스의 생성자를 호출
		-this()와 마찬가지로 super()역시 생성자이다.
		-this()는 같은 클래스의 다른 생성자를 호출 
		 super()는 부모클래스의 생성자를 호출
		-생성자의 첫 줄에는 조상클래스의 생성자를 호출해야 한다. (그렇기 때문에 둘다 존재할 수 없음)
		 자손클래스의 멤버가 조상클래스의 멤버를 사용할수 있으므로 조상의 멤버들이 먼저 초기화 되어야 한다.
		
		멤버
		멤버변수&메소드
		=클래스변수, 인스턴스변수
		=나머지 전부 메소드.
		
		8.제어자
		-클래스, 변수, 메소드의 선언부에 사용된다.
		-접근제어자 & 그 외 제어자.
		-접근제어자를 제일 왼쪽에 많이 둔다.
		-접근제어자
		:private - 클래스내에서만 사용가능
		:default - 같은 패키지 내에서만 사용가능
		:protected
		:public - 같은 프로젝트 내 어디서든 사용가능
		-그 외 제어자
		
		-static(클래스의, 공통적인) 멤버변수, 메서드, 초기화 블럭에 사용된다.
		:static변수
		->모든 인스턴스에서 공통적으로 사용한다.
		->인스턴스를 생성하지 않고도 호출할 수 있다.
		->클래스가 메모리에 로드될 때 생성된다.
		:static메소드
		->인스턴스 생성없이 사용가능
		->클래스 메소드 내에서는 인스턴스 멤버를 호출할 수 없다.
		
		-final(마지막의 변경할 수 없는)
		:변수에 사용 시 변경할 수 없는 상수가 된다.
		:메소드에 사용 시 오버라이드 할 수 없다.
		:클래스에 사용 시 상속할 수 없는 클래스가 된다.
		
		-abstract(추상의, 미완성된)
		:메소드와 클래스에만 사용가능
		:메소드에 사용 시 '구현부'는 작성하지 않는다.
		 void method(){
		 
		 }
		 abstract void method();
				
		9.접근제어자
		-private : 같은 클래스내에서 접근 가능
		-default : 같은 패키지 내에서 접근가능
		-protected : 같은 패키지 + 타 패키지의 자손 클래스
		-public : 접근 제한이 없다
		
		클래스에는 디폴트와 퍼블릭만 사용 가능
		변수와 메소드에는 4가지 전부 사용 가능
		클래스명, 변수명, 메소드명 앞에 접근제어자를 안주면 default를 줌
		
		10.캡슐화
		-접근제어자를 사용하는 이유
		:외부로부터 데이터를 보호하기 위한 목적
		:외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해 사용한다.
		
		11.다형성(polymorphism) 
		-여러가지 형태를 가질 수 있는 능력
		-한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다.
			Car c = new FireCar();
			Car c = new Ambulance();
		-다형성이 부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		
		12.참조변수의 형변환(상속관계를 전제로함)
		-서로 상속관계에 있는 클래스에서만 형변환이 가능하다.
		-자손타입 -> 부모타입(up-casting) 형변환 생략가능 - 부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다. / 주소를 갖고 있으므로 변수사용 가능.
		-부모타입 -> 자손타입(down-casting) 형변환 생략불가
		
		13.instancesof
		-참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.
		-연산결과가 true이면 참조변수가 검사한 타입으로 형변환이 가능하다.
		-클래스메소드와 클래스변수는 참조변수의 타입에 영향을 받는다.
		-참조변수의 타입에 영향을 받지 않는 것은 오버라이딩된 인스턴스 메소드 뿐이다.
		
		14.매개변수의 다형성
		-참조변수의 다형적인 특징은 메소드이 매개변수에도 적용된다.
		-
		
		15.여러객체 배열, vector
		-부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		-vector
		:배열을 사용할 경우 전체 크기를 한번 정하면 변경할 수 없다.
		 이를 vector클래스를 이용하여 해결할 수 있다.
		:동적으로 크기가 관리되는 객체배열 이라고 할 수 있다.
		
		Vector v = new Vector();
		Vector():10개의 객체를 저장할 수 있는 vector인스턴스를 생성한다.
		add():Vector에 객체를 추가할 때 사용하는 메소드.
		remove():Vector에서 객체를 삭제할 때 사용하는 메소드.
		isEmpty():Vector가 객체를 가지고 있는지 확인
		Object get(int index):인덱스 번째 객체를 반환한다.
		int size():Vector에 저정된 객체의 개수를 반환한다.
		
		16.추상클래스(Abstract class)
		-미완성된 클래스:미완성된 메소드를 가지고 있다는 의미
		-구성
		 abstract class 클래스명{
		 
		 }
		-추상 메소드
		:메소드는 선언부와 구현부로 구성되어 있다.
		:추상 메소드는 선언부만 작성되어 있고 구현부는 작성되지 않은 메소드를 의미한다.
		abstract 리턴타입 메소드명();
		-추상클래스로부터 상속받는 자손클래스는 오버라이드를 통해 조상인 클래스의 추상메소드를 구현해주면 됨
		
		17.인터페이스(interface)
		-일종의 추상클래스 이지만 추상메소드와 상수만을 멤버로 가진다.
		-인터페이스의 작성
		interface 인터페이스명{
			public static final 변수타입 변수명 = 값;
			public abstract 반환타입 메소드명(매개변수타입 매개변수명...);	
		}
		-> 생성자가 없기 때문에 혼자서는 인스턴스화가 불가능하다, 혼자서는 객체로 만들 수 없다.
		:모든 멤버변수는 public static final 이어야 한다. => 생략할 수 있다.(모두 그렇기 때문에)
		:모든 메소드는 public abstract이어야 한다. => 생략할 수 있다.
		
		-인터페이스의 상속
		:인터페이스는 인터페이스만을 상속하거나 받을 수 있다.
		->구현된 메소드를 상속받으면 더 이상 인터페이스가 아니게 되기 때문.
		:인터페이스는 다중상속이 가능하다.(구현부가 없기 때문에)
		:Object와 같은 최고 조상은 없다.
		
		-인터페이스 구현
		:자체로는 인스턴스를 생성할 수 없다.
		:자신이 정의된 추상메소드의 몸통을 만들어 주는 클래스를 작성해야 한다.
		(클래스명과 인터페이스명은 달라도 된다)
		:클래스의 확장(extends), 인터페이스의 구현(implements)
		:~able
		=>Movable
		=>IMove => IMoveImpl
		구성
		interface A{
		 void method();
		 void method2();
		}
		
		class B implements A{
		 메소드 구현;
		 메소드 구현;
		}
		
		-인터페이스의 다형성
		:인터페이스타입의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할 수 있다.
		
		-인터페이스의 장점
		:개발시간을 단축할 수 있다.
		:표준화가 가능하다.
		:서로 관계가 없는 클래스들에게  관계를 맺어줄 수 있다.
		:독립적인 프로그래밍이 가능하다.
		:7-26예제 꼭 풀어보기
		(7장 인터페이스의 대부분의 내용을 담고 있음)
		
		-인터페이스의 이해
		:클래스를 사용한 쪽(user)과 클래스를 제공하는 쪽(provider)이 있다.
		A(provider) - I(인터페이스의 선언부만 볼 수 있다) - B(user)
		
		18.내부클래스(inner class)
		-내부클래스란?
		:클래스 내에 선언된 클래스
		:서로 쉽게 접근할 수 있고 외부에서 볼 때 불필요한 클래스를 감춤으로 복잡성을 줄일 수 있다.
		
		-인스턴스 클래스
		:외부클래스의 인스턴스 멤버들과 관련된 작업을 수행한다.
		-스태틱 클래스
		:외부클래스의 클래스멤버들과 관련된 작업을 수행, 클래스 메소드에 관련된 작업을 수행한다.
		-지역 클래스
		:외부클래스의 메소드나 초기화블럭 안에 선언, 선언 영역 내에서만 사용 가능
		-익명 클래스
		:클래스의 선언과 객체의 생성을 동시에 진행한다.
		:이름이 없는 클래스(일회용)
		
		
		
		
		*/
		
		
		
		
		
}
}
